global x . f = f x

# exceptions
def test     x = prim "test"
def catch    x = prim "catch"
global try f x = if test x then f (catch x) else x
global raise x = prim "raise"

# bools
global true  x y = x
global false x y = y
global !x = x false true
global x & y = x y x # both sides are evaluated
global x | y = x x y

# tuples
global pair x y = _ x y
global first  p = p true
global second p = p false

# lists
global x, y = pair x y
global nil _ = true
global empty l = l (\_\_ false)
global head l = if l.empty then raise "empty list" else l.first
global tail l = if l.empty then raise "empty list" else l.second

# list transforms
global map   f   l = if l.empty then nil else f l.head, map f l.tail
global foldl f a l =     if l.empty then a   else foldl f (f a l.head) l.tail
global scanl f a l = a, (if l.empty then nil else scanl f (f a l.head) l.tail)
global foldr f a l =     if l.empty then a   else f l.head (foldr f a l.tail)
global scanr f a l =
  if l.empty then a, nil else
    def finish r = f l.head r.head, r
    finish (scanr f a l.tail)

# list helpers
global l ++ r    = foldr (_,_) r l
global reverse l = foldl (\a\b b,a) nil l
global flatten l = foldr (_++_) nil l
global len l     = foldl (\a\_ a+1) 0 l

# list choppers
global splitAt i l =
  if i <= 0 | l.empty then pair nil l else
    def finish r = pair (l.head, r.first) r.second
    finish (splitAt (i-1) l.tail)

global take i l = (splitAt i l).first
global drop i l = (splitAt i l).second
global at   i l = if i < 0 then nil else (drop i l).head

global splitUntil f l =
  if l.empty then pair nil l else
    if f l.head then pair nil l else
      def finish r = pair (l.head, r.first) r.second
      finish (splitUntil f l.tail)

global takeUntil f l = (splitUntil f l).first
global dropUntil f l = (splitUntil f l).second
global find f l = at 0 (dropUntil f l)
global exists f l = !empty (dropUntil f l)
global forall f l = empty (dropUntil (\x !f x) l)

global splitBy f l =
  if l.empty then pair nil nil else
    def finish r =
      if f l.head
      then pair (l.head, r.first) r.second
      else pair r.first (l.head, r.second)
    finish (splitBy f l.tail)

global filter f l = #(splitBy f l).first
#bad:
#  if l.empty then nil else
#    def rest = filter f l.tail
#    if f l.head then l.head, rest else rest
#ok:
  if l.empty then nil
  else if f l.head then l.head, filter f l.tail else filter f l.tail
#bad:
#  if l.empty then nil else
#    def finish r = if f l.head then l.head, r else r
#    finish (filter f l.tail)
#bad:
#  if l.empty then nil else
#    (\r (if f l.head then l.head, r else r)) (filter f l.tail)

# Tranposition is only it's own inverse when the lists have non-increasing size
global transpose l =
  def todo = filter (!_.empty) l
  def heads = map first todo
  def tails = map second todo
  if todo.empty then nil else heads, transpose tails

# f should be a less-than comparison
global sortBy f l =
  if l.empty then nil else
    def key = l.head
    def split = splitBy (f key) l.tail
    sortBy f split.second ++ (key, sortBy f split.first)
global sort l = sortBy (_<_) l

global collate f l r =
  if l.empty
  then
    if r.empty then 0 else -1
  else
    if r.empty then 1 else
      def cmp = f l.head r.head
      if cmp == 0
      then collate f l.tail r.tail
      else cmp

# string operations
def catopen    = prim "catopen" # if inside, breaks eval order!
def catclose c = prim "catclose"
def catadd c s = prim "catadd"
global cat l =
  catclose (foldl catadd catopen l)
global catWith s l =
  if l.empty then "" else
    def inserted = foldr (s, _, _) nil l
    cat (inserted.tail)

# integer operations
global +x = x
global -x = prim "neg"
global ~x = prim "com"
global x + y = prim "add"
global x - y = prim "sub"
global x * y = prim "mul"
global x / y = prim "div"
global x % y = prim "mod"
global x << y = prim "shl"
global x >> y = prim "shr"
global x ^ y = prim "exp"
global root x n = (\_\_ prim "root") n x
global sqrt x = root 2 x
global abs x = prim "abs"
global xor x y = prim "xor"
global and x y = prim "and"
global or  x y = prim "or"
global gcd x y = prim "gcd"
global lcm x y = prim "lcm"
global powm x y m = prim "powm" # fast version of: (x^y) % m

global seq n =
  def helper i = if i >= n then nil else i, helper (i+1)
  helper 0

# Type conversion
global strbase base n = prim "str" # int -> string
global intbase base s = prim "int" # string -> int
global str n = strbase 10 n
global int s = intbase 0 s

# Comparison operators for integers and strings
global x <  y = prim "lt"
global x >  y = y < x
global x >= y = !(x < y)
global x <= y = !(y < x)
global x == y = prim "eq"
global x != y = !(x == y)
global cmp x y = prim "cmp" # lt=-1, eq=0, gt=1

# Regular expressions
global quote s = prim "quote" # str -> str  (quoted for use in a regexp)
global match r =              # regexp str -> bool
  def compile r = prim "re2"
  def match r s = prim "match"
  match (compile r)
global extract r =            # regexp-with-(exp)s str -> str list
  def compile r = prim "re2"
  def extract r s = prim "extract"
  extract (compile r)
global replace r =            # regexp replacement str -> str
  def compile r = prim "re2"
  def replace r s t = prim "replace"
  replace (compile r)
global tokenize r =            # regexp seperator str -> str list
  def compile r = prim "re2"
  def tokenize r s = prim "tokenize"
  tokenize (compile r)

# Find sources files
global sources dir regexp = prim "sources"

# Internal job execution implementation
def implode l = cat (foldr (_, "\0", _) nil l)
def runjob cache env stdin dir files cmd =
  def run cache env stdin dir files cmd = prim "job"
  def result = run cache env stdin dir files cmd
  # Defer the execution of these, as they call to the database
  def stdout  r = prim "job_stdout"
  def stderr  r = prim "job_stderr"
  def inputs  r = prim "job_inputs"
  def outputs r = prim "job_outputs"
  def get i = # We use this getter hide the bare JobResult type
    if      i == 0 then stdout  result
    else if i == 1 then stderr  result
    else if i == 2 then inputs  result
    else if i == 3 then outputs result
    else nil
  get

# Access the output of a job
global stdout  job = job 0
global stderr  job = job 1
global inputs  job = job 2
global outputs job = job 3

global null = "/dev/null"

# file paths are all relative to workspace root
global job env dir files cmd = runjob 1 env.implode null dir files.implode cmd.implode
